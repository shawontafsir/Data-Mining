"""
Name: Khalid Hasan
BearPass: M03543550

How to run:
1. Place the source file "hw5_Khalid_Hasan.py" and "synthetic_2D.txt".
2. Open a terminal (or, command-prompt) in this directory and run the following command:
    python hw5_Khalid_Hasan.py

**Make sure, you have python and python's numpy and pandas library installed to run this command.

Summary:
1. This file contains the "KMeans" class for the implementation of the K-means algorithm.
2. The function named "fit" is to train the model and update the cluster mean parameter
    so that the model gives the best possible clusters.
3. Normalization: Z-score normalization
4. Stopping criteria during the model training: The mean does not change.
5. The main function calls the KMeans class to cluster the given data
    and prints some evaluation statistics along with actual and predicted cluster labels.
6. Accuracy of the model: This implementation has received varieties of accuracy from 8% to 90%
    for given data.
"""

import random

import numpy as np
import pandas as pd


class KMeans:
    def __init__(self, n_clusters=2):
        self.means = None
        self.n_clusters = n_clusters

    @staticmethod
    def euclidean_distance(point1: pd.Series, point2: tuple):
        """
        Measure Euclidean distance between two points.
        distance(p, q) = sqrt(sum(p-q)***2)

        :param point1: A point in pandas series
        :param point2: A tuple
        :return: The Euclidean distance
        """
        distance = np.sqrt(np.sum((point1 - point2) ** 2))

        return distance

    def get_nearest_cluster(self, row):
        # Calculate distances from each point to each mean points centering the clusters
        distances = {
            cluster_label: self.euclidean_distance(row[:-2], mean) for cluster_label, mean in self.means.items()
        }

        # get the nearest cluster based on min distance from the point
        predicted_cluster = min(distances, key=distances.get)

        return predicted_cluster

    @staticmethod
    def accuracy_score(expected, predicted):
        # return accuracy measure
        return np.sum(expected == predicted) / len(expected)

    def fit(self, _training_df: pd.DataFrame):
        # A column to store predicted cluster
        _training_df["predicted_cluster"] = None

        # Z-score Normalization (Standardization)
        normalized_columns = _training_df.columns[:-2]
        _training_df[normalized_columns] = (
                (_training_df[normalized_columns] - _training_df[normalized_columns].mean())
                /
                _training_df[normalized_columns].std()

        )

        # Initialize the mean point for each cluster
        self.means = {
            cluster_label: tuple(
                random.random() for ind in range(_training_df.shape[1]-2)
            ) for cluster_label in range(self.n_clusters)
        }

        while True:
            # Copy of means before update
            means_before_update = self.means.copy()
            print(means_before_update)

            # Get the predicted cluster
            _training_df["predicted_cluster"] = _training_df.apply(self.get_nearest_cluster, axis=1)

            # Iterate the newly predicted clusters grouped by label
            for group_label, group_data in _training_df.groupby("predicted_cluster"):
                # Update mean points generated by predicted cluster
                self.means[group_label] = tuple(group_data[_training_df.columns[:-2]].mean())

            # Check if means are not changed
            if self.means == means_before_update:
                break

        # Statistics
        for cluster_label, cluster_data in _training_df.groupby("predicted_cluster"):
            print("=====================")
            print(f"Cluster: {cluster_label}")
            print(f"Size of cluster {cluster_label} is {len(cluster_data)}")
            mis_clustered_objects = cluster_data[cluster_data["actual_cluster"] != cluster_data["predicted_cluster"]]
            print(f"Number of objects mis-clustered in this cluster {len(mis_clustered_objects)}")
            for index, obj in mis_clustered_objects.iterrows():
                print(f"({tuple(obj[:-2])}, {obj['actual_cluster']})")

        # Calculate the prediction accuracy
        accuracy = self.accuracy_score(_training_df["actual_cluster"], _training_df["predicted_cluster"])

        print(f"Accuracy rate is {round(accuracy * 100, 4)}%")

        return self


if __name__ == "__main__":
    # Read training and test data
    training_df = pd.read_csv("./synthetic_2D.txt", sep=' ', header=None)
    training_df.rename(columns={training_df.columns[-1]: "actual_cluster"}, inplace=True)
    clusters = training_df["actual_cluster"].unique()

    # Seed the random number generator so that we get the same results each time
    random.seed(0)

    # Train the model for training data
    KMeans(n_clusters=len(clusters)).fit(training_df)
